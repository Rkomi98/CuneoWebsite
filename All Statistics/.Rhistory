# Fill missing values for `n_receptions`, `positivity`, and `rate` with zeros (or other defaults)
reception_rate <- reception_rate %>%
mutate(
n_receptions = replace_na(n_receptions, 0),
positivity = replace_na(positivity, 0),
rate = replace_na(rate, 0)
)
# Plot the heatmap for reception frequency with positivity values
ggplot(reception_rate, aes(x, y, fill = rate)) +
geom_tile() +
geom_text(aes(label = scales::percent(positivity)), color = "white", size = 4) +  # Add positivity text
ggcourt("lower", labels = NULL) +
scale_fill_gradient2(name = "Rate: reception\nend location") +
ggtitle(paste("Reception Analysis for", ifelse(input$player == "All Players", input$team, input$player)))
} else if (input$skill == "Attack") {
# Attack analysis
# Attack analysis: Generate heatmap kernel density estimate for attack end coordinates
attack_data <- px %>%
filter(skill == "Attack", team == input$team)
if (input$player != "All Players") {
attack_data <- attack_data %>%
filter(player_name == input$player)
}
if (input$attack_description != "All Descriptions") {
attack_data <- attack_data %>%
filter(attack_description == input$attack_description)
}
# Generate KDE heatmap using attack end coordinates
hx <- ov_heatmap_kde(attack_data %>% dplyr::select(end_coordinate_x, end_coordinate_y),
resolution = "coordinates", court = "upper")
# Plot the heatmap for attack end locations
ggplot(hx, aes(x, y, fill = density)) +
scale_fill_distiller(palette = "Spectral", guide = "none") +
geom_raster() +
ggcourt(labels = NULL, court = "upper") +  # Plot court over the heatmap
ggtitle(paste("Attack Heatmap for", ifelse(input$player == "All Players", input$team, input$player)))
} else if (input$skill == "Block") {
# Block analysis: Distribution of setters' positions or actions
block_data <- px %>%
filter(skill == "Block", team == input$team)
if (input$player != "All Players") {
block_data <- block_data %>%
filter(player_name == input$player)
}
# Plot setter distribution using discrete color scale
ggplot(block_data, aes(x = start_coordinate_x, y = start_coordinate_y, color = player_name)) +
geom_point(alpha = 0.7) +
scale_color_viridis_d() +  # Use discrete color scale
ggcourt() +
ggtitle(paste("Block Distribution for", ifelse(input$player == "All Players", input$team, input$player)))
}
})
# Player stats table
output$player_stats <- renderTable({
req(filtered_data())
filtered_data()
})
}
shinyApp(ui, server)
View(reception_rate4)
View(reception_rate4)
server <- function(input, output, session) {
# Initial message when no team is selected
output$message <- renderText({
if (is.null(input$team)|| length(input$team) == 0) {
return("Select a team to see statistics.")
} else {
return(NULL)
}
})
# Dynamic player selection based on team
output$player_select <- renderUI({
req(input$team, cancelOutput = TRUE)  # Ensure team is selected
players <- final_table %>%
filter(team == input$team) %>%
pull(player_name) %>%
unique()
selectInput("player", "Select Player", choices = c("All Players", players))
})
# Dynamic attack description selection based on the selected team and skill
output$attack_description_select <- renderUI({
req(input$team, input$skill)  # Ensure a team and skill are selected
if (input$skill == "Attack") {
descriptions <- px %>%
filter(skill == "Attack", team == input$team, player_name==input$player) %>%
pull(attack_description) %>%
unique()
selectInput("attack_description", "Select Attack Description", choices = c("All Descriptions", descriptions))
} else {
return(NULL)  # Return NULL if skill is not Attack
}
})
# Reactive data filtering based on selected team and player
filtered_data <- reactive({
req(input$team)  # Ensure the input exists
if (is.null(input$team) || length(input$team) == 0) return(NULL)  # Check for NULL or zero-length input
data <- final_table %>%
filter(team == input$team)
if (input$player != "All Players" && !is.null(input$player) && input$player != "") {
data <- data %>% filter(player_name == input$player)
}
if (nrow(data) == 0) return(NULL)  # Check for empty filtered data
data
})
# Plot generation
output$skill_plot <- renderPlot({
req(input$skill, input$team, input$player, filtered_data())
if(input$skill == "Serve") {
# Filter serves by the selected team and player
filtered_serves <- px %>%
filter(skill == "Serve",
team == input$team,
player_name == input$player)
filtered_serves <- filtered_serves %>%
filter(!is.na(start_zone), !is.na(end_zone))
# Convert zones to coordinates (since we are using zones instead of coordinates)
filtered_serves <- convert_zones_to_coordinates(filtered_serves)
# Ensure that 'evaluation' contains only Ace, Error, or Other
filtered_serves <- filtered_serves %>%
mutate(evaluation = ifelse(evaluation %in% c("Ace", "Error"), evaluation, "Other"))
# Plot the serves with arrows and customized colors for Ace, Error, and Other
ggplot(filtered_serves, aes(x = start_coordinate_x, y = start_coordinate_y,
xend = end_coordinate_x, yend = end_coordinate_y, colour = evaluation)) +
geom_segment(arrow = arrow(length = unit(2, "mm"), type = "closed", angle = 20)) +
scale_colour_manual(values = c(Ace = "limegreen", Error = "firebrick", Other = "dodgerblue"),
name = "Evaluation") +
ggcourt(labels = c("Serving team", "Receiving team")) +
ggtitle(paste("Serve Analysis for", input$player, "from", input$team))
} else if (input$skill == "Reception") {
# Reception analysis: Calculate positivity rate for each player in each zone
reception_rate <- px %>%
filter(skill == "Reception", team == input$team, !is.na(end_zone))
if (input$player != "All Players") {
reception_rate <- reception_rate %>%
filter(player_name == input$player)
}
# Calculate positivity and reception rate by zone
reception_rate <- reception_rate %>%
group_by(end_zone) %>%
summarize(
n_receptions = n(),
positivity = sum(evaluation_code %in% c('#', '+')) / n_receptions  # Correct positivity calculation
) %>%
mutate(rate = n_receptions / sum(n_receptions)) %>%
ungroup()
all_zones <- tibble(
end_zone = 1:9,
x = c(3, 3, 2, 1, 1, 2, 1, 2, 3),  # Predefined x-coordinates for each zone
y = c(1, 3, 3, 3, 1, 1, 2, 2, 2)   # Predefined y-coordinates for each zone
)
# Add coordinates for the reception zones
#reception_rate <- cbind(reception_rate, dv_xy(reception_rate$end_zone, end = "lower"))
# Left join to ensure all zones 1-9 are present in the dataset
reception_rate <- left_join(all_zones, reception_rate, by = "end_zone")
# Fill missing values for `n_receptions`, `positivity`, and `rate` with zeros (or other defaults)
reception_rate <- reception_rate %>%
mutate(
n_receptions = replace_na(n_receptions, 0),
positivity = replace_na(positivity, 0),
rate = replace_na(rate, 0)
)
# Plot the heatmap for reception frequency with positivity values
ggplot(reception_rate, aes(x, y, fill = rate)) +
geom_tile() +
geom_text(aes(label = scales::percent(positivity)), color = "white", size = 4) +  # Add positivity text
ggcourt("lower", labels = NULL) +
scale_fill_gradient2(name = "Rate: reception\nend location") +
ggtitle(paste("Reception Analysis for", ifelse(input$player == "All Players", input$team, input$player)))
} else if (input$skill == "Attack") {
# Attack analysis
# Attack analysis: Generate heatmap kernel density estimate for attack end coordinates
attack_data <- px %>%
filter(skill == "Attack", team == input$team)
if (input$player != "All Players") {
attack_data <- attack_data %>%
filter(player_name == input$player)
}
if (input$attack_description != "All Descriptions") {
attack_data <- attack_data %>%
filter(attack_description == input$attack_description)
}
# Generate KDE heatmap using attack end coordinates
hx <- ov_heatmap_kde(attack_data %>% dplyr::select(end_coordinate_x, end_coordinate_y),
resolution = "coordinates", court = "upper")
# Plot the heatmap for attack end locations
ggplot(hx, aes(x, y, fill = density)) +
scale_fill_distiller(palette = "Spectral", guide = "none") +
geom_raster() +
ggcourt(labels = NULL, court = "upper") +  # Plot court over the heatmap
ggtitle(paste("Attack Heatmap for", ifelse(input$player == "All Players", input$team, input$player)))
} else if (input$skill == "Block") {
# Block analysis: Distribution of setters' positions or actions
block_data <- px %>%
filter(skill == "Block", team == input$team)
if (input$player != "All Players") {
block_data <- block_data %>%
filter(player_name == input$player)
}
# Plot setter distribution using discrete color scale
ggplot(block_data, aes(x = start_coordinate_x, y = start_coordinate_y, color = player_name)) +
geom_point(alpha = 0.7) +
scale_color_viridis_d() +  # Use discrete color scale
ggcourt() +
ggtitle(paste("Block Distribution for", ifelse(input$player == "All Players", input$team, input$player)))
}
})
# Player stats table
output$player_stats <- renderTable({
req(filtered_data())
filtered_data()
})
}
shinyApp(ui, server)
px$team.unique()
px$team
a<- unique(px$team)
a
FOCOL <- final_table %>%
filter(team == 'GS FO.CO.L. VOLLEY LEGNANO')
View(FOCOL)
shinyApp(ui, server)
FOCOL <- px %>%
filter(team == 'GS FO.CO.L. VOLLEY LEGNANO')
View(FOCOL)
shinyApp(ui, server)
reception_rate5 <- FOCOL %>%
filter(skill == "Reception", !is.na(end_zone))
reception_rate6 <- reception_rate5 %>%
group_by(end_zone) %>%
summarize(
n_receptions = n(),
positivity = sum(evaluation_code %in% c('#', '+')) / n_receptions  # Correct positivity calculation
) %>%
mutate(rate = n_receptions / sum(n_receptions)) %>%
ungroup()
all_zones <- tibble(
end_zone = 1:9,
x = c(3, 3, 2, 1, 1, 2, 1, 2, 3),  # Predefined x-coordinates for each zone
y = c(1, 3, 3, 3, 1, 1, 2, 2, 2)   # Predefined y-coordinates for each zone
)
reception_rate6 <- left_join(all_zones, reception_rate6, by = "end_zone")
reception_rate6 <- reception_rate6 %>%
mutate(
n_receptions = replace_na(n_receptions, 0),
positivity = replace_na(positivity, 0),
rate = replace_na(rate, 0)
)
View(reception_rate6)
View(reception_rate4)
ggplot(reception_rate6, aes(x, y, fill = rate)) +
geom_tile() +
geom_text(aes(label = scales::percent(positivity)), color = "white", size = 4) +  # Add positivity text
ggcourt("lower", labels = NULL) +
scale_fill_gradient2(name = "Rate: reception\nend location")
library(shiny)
library(shinydashboard)
library(ggplot2)
library(dplyr)
library(datavolley)
library(ovlytics)
library(DT)
library(tidyr)
final_table <- readRDS("final_table_ItalyB1.rds")
#d <- list.files("Legnano/Scout/", pattern = "dvw$", full.names = TRUE)
d <- list.files("B1_Scout/", pattern = "dvw$", full.names = TRUE)
lx <- list()
# Read each file with error handling
for (fi in seq_along(d)) {
tryCatch({
lx[[fi]] <- dv_read(d[fi], insert_technical_timeouts = FALSE)
}, error = function(e) {
message("Error reading file ", d[fi], ": ", e$message)
# If the error is specifically about the [3SCOUT] section, try to read without it
if (grepl("\\[3SCOUT\\]", e$message)) {
message("Attempting to read file without [3SCOUT] section")
file_content <- readLines(d[fi])
scout_index <- grep("\\[3SCOUT\\]", file_content)
if (length(scout_index) > 0) {
file_content <- file_content[1:(scout_index-1)]
temp_file <- tempfile(fileext = ".dvw")
writeLines(file_content, temp_file)
lx[[fi]] <- dv_read(temp_file, insert_technical_timeouts = FALSE)
file.remove(temp_file)
}
}
})
}
## now extract the play-by-play component from each and bind them together
px <- list()
for (fp in seq_along(lx)) px[[fp]] <- plays(lx[[fp]])
px <- do.call(rbind, px)
# Function to convert zones to coordinates
convert_zones_to_coordinates <- function(data) {
# Define fixed start coordinates based on start_zone
data <- data %>%
mutate(
start_coordinate_x = case_when(
start_zone == 5 ~ 1.08125,
start_zone == 6 ~ 2.10125,
start_zone == 1 ~ 3.18125,
TRUE ~ NA_real_  # Default to NA if no match
),
start_coordinate_y = case_when(
start_zone == 5 ~ 0.462963,
start_zone == 6 ~ 0.462963,
start_zone == 1 ~ 0.462963,
# Add other start zones here if needed
TRUE ~ NA_real_
),
# Generate random end coordinates based on end_zone
end_coordinate_x = case_when(
end_zone == 1 ~ runif(n(), 0.7, 1.2),
end_zone == 6 ~ runif(n(), 1.5, 2.2),
end_zone == 5 ~ runif(n(), 2.3, 3),
TRUE ~ NA_real_
),
end_coordinate_y = case_when(
end_zone %in% c(1, 6, 5) ~ runif(n(), 4.8, 5.8),
TRUE ~ NA_real_
)
)
return(data)
}
# Check and prepare the data
if(!"team" %in% names(px)) {
stop("The 'team' column is missing from the data.")
}
if(!"player_name" %in% names(px)) {
if("player" %in% names(px)) {
final_table <- final_table %>% rename(player_name = player)
} else {
stop("Neither 'player_name' nor 'player' column found in the data.")
}
}
# Start Dashboard
ui <- dashboardPage(
dashboardHeader(title = "Volleyball Statistics"),
dashboardSidebar(
selectInput("team", "Select Team", choices = unique(final_table$team)),
selectInput("skill", "Select Skill", choices = c("Serve", "Reception", "Attack", "Block")),
uiOutput("player_select"),
conditionalPanel(
condition = "input.skill == 'Attack'",
uiOutput("attack_description_select")  # Show only if skill is Attack
)
),
dashboardBody(
#fluidRow(
#  box(textOutput("message"))## Message to display when no team is selected
#),
fluidRow(
box(plotOutput("skill_plot"), width = 12)
),
fluidRow(
box(tableOutput("player_stats"), width = 12)
)
)
)
server <- function(input, output, session) {
# Initial message when no team is selected
output$message <- renderText({
if (is.null(input$team)|| length(input$team) == 0) {
return("Select a team to see statistics.")
} else {
return(NULL)
}
})
# Dynamic player selection based on team
output$player_select <- renderUI({
req(input$team, cancelOutput = TRUE)  # Ensure team is selected
players <- final_table %>%
filter(team == input$team) %>%
pull(player_name) %>%
unique()
selectInput("player", "Select Player", choices = c("All Players", players))
})
# Dynamic attack description selection based on the selected team and skill
output$attack_description_select <- renderUI({
req(input$team, input$skill)  # Ensure a team and skill are selected
if (input$skill == "Attack") {
descriptions <- px %>%
filter(skill == "Attack", team == input$team, player_name==input$player) %>%
pull(attack_description) %>%
unique()
selectInput("attack_description", "Select Attack Description", choices = c("All Descriptions", descriptions))
} else {
return(NULL)  # Return NULL if skill is not Attack
}
})
# Reactive data filtering based on selected team and player
filtered_data <- reactive({
req(input$team)  # Ensure the input exists
if (is.null(input$team) || length(input$team) == 0) return(NULL)  # Check for NULL or zero-length input
data <- final_table %>%
filter(team == input$team)
if (input$player != "All Players" && !is.null(input$player) && input$player != "") {
data <- data %>% filter(player_name == input$player)
}
if (nrow(data) == 0) return(NULL)  # Check for empty filtered data
data
})
# Plot generation
output$skill_plot <- renderPlot({
req(input$skill, input$team, input$player, filtered_data())
if(input$skill == "Serve") {
# Filter serves by the selected team and player
filtered_serves <- px %>%
filter(skill == "Serve",
team == input$team,
player_name == input$player)
filtered_serves <- filtered_serves %>%
filter(!is.na(start_zone), !is.na(end_zone))
# Convert zones to coordinates (since we are using zones instead of coordinates)
filtered_serves <- convert_zones_to_coordinates(filtered_serves)
# Ensure that 'evaluation' contains only Ace, Error, or Other
filtered_serves <- filtered_serves %>%
mutate(evaluation = ifelse(evaluation %in% c("Ace", "Error"), evaluation, "Other"))
# Plot the serves with arrows and customized colors for Ace, Error, and Other
ggplot(filtered_serves, aes(x = start_coordinate_x, y = start_coordinate_y,
xend = end_coordinate_x, yend = end_coordinate_y, colour = evaluation)) +
geom_segment(arrow = arrow(length = unit(2, "mm"), type = "closed", angle = 20)) +
scale_colour_manual(values = c(Ace = "limegreen", Error = "firebrick", Other = "dodgerblue"),
name = "Evaluation") +
ggcourt(labels = c("Serving team", "Receiving team")) +
ggtitle(paste("Serve Analysis for", input$player, "from", input$team))
} else if (input$skill == "Reception") {
# Reception analysis: Calculate positivity rate for each player in each zone
reception_rate <- px %>%
filter(skill == "Reception", team == input$team, !is.na(end_zone))
if (input$player != "All Players") {
reception_rate <- reception_rate %>%
filter(player_name == input$player)
}
# Calculate positivity and reception rate by zone
reception_rate <- reception_rate %>%
group_by(end_zone) %>%
summarize(
n_receptions = n(),
positivity = sum(evaluation_code %in% c('#', '+')) / n_receptions  # Correct positivity calculation
) %>%
mutate(rate = n_receptions / sum(n_receptions)) %>%
ungroup()
all_zones <- tibble(
end_zone = 1:9,
x = c(3, 3, 2, 1, 1, 2, 1, 2, 3),  # Predefined x-coordinates for each zone
y = c(1, 3, 3, 3, 1, 1, 2, 2, 2)   # Predefined y-coordinates for each zone
)
# Add coordinates for the reception zones
#reception_rate <- cbind(reception_rate, dv_xy(reception_rate$end_zone, end = "lower"))
# Left join to ensure all zones 1-9 are present in the dataset
reception_rate <- left_join(all_zones, reception_rate, by = "end_zone")
# Fill missing values for `n_receptions`, `positivity`, and `rate` with zeros (or other defaults)
reception_rate <- reception_rate %>%
mutate(
n_receptions = replace_na(n_receptions, 0),
positivity = replace_na(positivity, 0),
rate = replace_na(rate, 0)
)
# Plot the heatmap for reception frequency with positivity values
ggplot(reception_rate, aes(x, y, fill = rate)) +
geom_tile() +
geom_text(aes(label = scales::percent(positivity)), color = "white", size = 4) +  # Add positivity text
ggcourt("lower", labels = NULL) +
scale_fill_gradient2(name = "Rate: reception\nend location") +
ggtitle(paste("Reception Analysis for", ifelse(input$player == "All Players", input$team, input$player)))
} else if (input$skill == "Attack") {
# Attack analysis
# Attack analysis: Generate heatmap kernel density estimate for attack end coordinates
attack_data <- px %>%
filter(skill == "Attack", team == input$team)
if (input$player != "All Players") {
attack_data <- attack_data %>%
filter(player_name == input$player)
}
if (input$attack_description != "All Descriptions") {
attack_data <- attack_data %>%
filter(attack_description == input$attack_description)
}
# Generate KDE heatmap using attack end coordinates
hx <- ov_heatmap_kde(attack_data %>% dplyr::select(end_coordinate_x, end_coordinate_y),
resolution = "coordinates", court = "upper")
# Plot the heatmap for attack end locations
ggplot(hx, aes(x, y, fill = density)) +
scale_fill_distiller(palette = "Spectral", guide = "none") +
geom_raster() +
ggcourt(labels = NULL, court = "upper") +  # Plot court over the heatmap
ggtitle(paste("Attack Heatmap for", ifelse(input$player == "All Players", input$team, input$player)))
} else if (input$skill == "Block") {
# Block analysis: Distribution of setters' positions or actions
block_data <- px %>%
filter(skill == "Block", team == input$team)
if (input$player != "All Players") {
block_data <- block_data %>%
filter(player_name == input$player)
}
# Plot setter distribution using discrete color scale
ggplot(block_data, aes(x = start_coordinate_x, y = start_coordinate_y, color = player_name)) +
geom_point(alpha = 0.7) +
scale_color_viridis_d() +  # Use discrete color scale
ggcourt() +
ggtitle(paste("Block Distribution for", ifelse(input$player == "All Players", input$team, input$player)))
}
})
# Player stats table
output$player_stats <- renderTable({
req(filtered_data())
filtered_data()
})
}
shinyApp(ui, server)
shinyApp(ui, server)
shinyApp(ui, server)
